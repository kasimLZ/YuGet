namespace System
{
	/// <summary>
	/// Distributed Increment Snowflake ID
	/// In the distributed project, the primary key ID generated by multiple service hosts will not be duplicated and will keep increasing
	/// </summary>
	public partial struct SFID
	{
		/// <summary>
		/// Constructs a Snowflake Id object with <see cref="string"/>
		/// </summary>
		/// <param name="Id">Snowflake Id for <see cref="string"/></param>
		/// <param name="setting">Conversion configuration model</param>
		public SFID(string Id, SFIDSetting? setting = null) : this(long.Parse(Id), setting) { }

		/// <summary>
		/// Constructs a Snowflake Id object with <see cref="long"/>
		/// </summary>
		/// <param name="Id">Snowflake Id for <see cref="long"/></param>
		/// <param name="setting">Conversion configuration model</param>
		public SFID(long Id, SFIDSetting? setting = null)
		{
			// When no configuration model is passed in, the default model is used
			if (!setting.HasValue) setting = DefaultSetting;

			SnowflakeId = Id;

			var Prefix = Id >> setting.Value.TimeStampLeftShift;
			UtcTime = setting.Value.BeginTime.AddMilliseconds(Prefix);

			
			UtcTimestamp = Prefix + setting.Value.BeginTimeStamp;

			//The target byte is debited to the last bit, 
			//and then moved back to make use of the characteristics of lost precision to make all non-target positions return to zero. 
			//The XOR operation is used to obtain unexpected data for the target word.
			Sequence = ((Id >> setting.Value.WorkerIdShift) << setting.Value.WorkerIdShift) ^ Id;
			MachineId = (Prefix << (setting.Value.WorkerIdBits)) ^ (Id >> setting.Value.SequenceBits);

			CheckDataBySetting(setting.Value);
		}

		/// <summary>
		/// Construct a new Snowflake Id with a custom timestamp, mechanical code, and serial number
		/// </summary>
		/// <param name="UtcTimestamp"><see cref="UtcTimestamp"/></param>
		/// <param name="MachineId"><see cref="MachineId"/></param>
		/// <param name="Sequence"><see cref="Sequence"/></param>
		/// <param name="setting">Conversion configuration model</param>
		public SFID(long UtcTimestamp, long MachineId, long Sequence, SFIDSetting? setting = null)
		{
			if (!setting.HasValue) setting = DefaultSetting;

			this.UtcTimestamp = UtcTimestamp;
			this.MachineId = MachineId;
			this.Sequence = Sequence;

			UtcTime = UtcTimestamp.ToUtcDateTime();

			SnowflakeId = Combination(UtcTimestamp, MachineId, Sequence, setting.Value);

			CheckDataBySetting(setting.Value);
		}

		private const string MACHINE_ID_OUT_OF_RANGE = "Mechanical code used \"{0}\" Exceeded the maximum number of bytes set \"{1}\", range [0 ~ {2}]";
		private const string SEQUENCE_OUT_OF_RANGE = "Sequence code used \"{0}\" Exceeded the maximum number of bytes set \"{1}\", range [0 ~ {2}]";
		private const string UTC_TSLESS_ZERO = "UTC timestamp cannot be less than 0";

		/// <summary>
		/// Detect data rationality based on configuration model
		/// </summary>
		/// <param name="setting">Conversion configuration model</param>
		private void CheckDataBySetting(SFIDSetting setting)
		{
			if(UtcTimestamp < 0)
			{
				throw new ArgumentOutOfRangeException(UTC_TSLESS_ZERO);
			}

			if (MachineId < 0 || MachineId >= setting.MaxWorkerId)
			{
				throw new ArgumentOutOfRangeException(string.Format(MACHINE_ID_OUT_OF_RANGE, MachineId, setting.WorkerIdBits, setting.MaxWorkerId));
			}

			if (Sequence < 0 || Sequence >= setting.SequenceMask)
			{
				throw new ArgumentOutOfRangeException(string.Format(SEQUENCE_OUT_OF_RANGE, MachineId, setting.WorkerIdBits, setting.MaxWorkerId));
			}
		}

		/// <summary>
		/// Snowflake Id build time
		/// </summary>
		public DateTime UtcTime { get; private set; }

		/// <summary>
		/// UTC timestamp
		/// </summary>
		public long UtcTimestamp { get; private set; }

		/// <summary>
		/// Machine number
		/// </summary>
		public long MachineId { get; private set; }

		/// <summary>
		/// Generate serial numbers in milliseconds
		/// </summary>
		public long Sequence { get; private set; }

		/// <summary>
		/// Full Snowflake Id
		/// </summary>
		private long SnowflakeId { get; set; }

		/// <summary>
		/// Convert <see cref="long"/> to <see cref="SFID"/>, you can refer to <see cref="SFID(long, SFIDSetting?)"/>
		/// </summary>
		/// <param name="snowflakeId"></param>
		/// <param name="setting">Conversion configuration model</param>
		/// <returns></returns>
		public static SFID Parse(long snowflakeId, SFIDSetting? setting = null) => new SFID(snowflakeId, setting);

		#region Logical operations and implicit type conversion

		public static implicit operator SFID(long value) => Parse(value);

		public static implicit operator long(SFID value) => value.SnowflakeId;

		public static bool operator == (SFID id1, SFID id2) => id1.SnowflakeId == id2.SnowflakeId;

		public static bool operator !=(SFID id1, SFID id2) => id1.SnowflakeId != id2.SnowflakeId;

		public static bool operator >(SFID id1, SFID id2) => id1.SnowflakeId > id2.SnowflakeId;

		public static bool operator >=(SFID id1, SFID id2) => id1.SnowflakeId >= id2.SnowflakeId;

		public static bool operator <(SFID id1, SFID id2) => id1.SnowflakeId < id2.SnowflakeId;

		public static bool operator <=(SFID id1, SFID id2) => id1.SnowflakeId <= id2.SnowflakeId;

		#endregion

		#region Overriding the default method
		public override bool Equals(object obj) => SnowflakeId == ((SFID)obj).SnowflakeId;

		public override string ToString() => SnowflakeId.ToString();

		public override int GetHashCode() => base.GetHashCode();
		#endregion
	}


}
